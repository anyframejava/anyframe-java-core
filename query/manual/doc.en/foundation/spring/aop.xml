<chapter id="foundation_spring_aop">
	<title>AOP(Aspect Oriented Programming)</title>
	<para>
		The following is an excerpt from Microsoftware which associates with ZDNet Korea.
		Aspect Oriented Programming (hereinafter, "AOP") is a new programming paradigm by providing a new level of aspect 
		to the existing programming technological development.
		The basic concept to understand the need of AOP is Separation of Concerns,
		and almost all programming paradigm separates problem domain in independent module through this Separation of Concerns process.
		
	

		 
	</para>

	<itemizedlist>
		<listitem>
			<para>Procedural programming  : Composing separated concerns as procedure</para>
		</listitem>

		<listitem>
			<para>Object Oriented Programming (hereinafter, "OOP") : Composing separated concerns as class</para>
		</listitem>
	</itemizedlist>

	<para>
		<emphasis role="bold">Why AOP?</emphasis>
	</para>

	<para>
		The concept of AOP starts from the recognition of the issue that request difficult to develop in separated module
		occurs in actual application design and development even by applying OOP.
		AOP calls this Crosscutting Concerns.
		
		In addition, core concerns refers to concern domain of which core value and purpose of the system is shown as it is.
		These core concerns can be easily modularized and abstracted through existing Object-Oriented Analysis/Design (OOAD),
		but Crosscutting concerns are very hard to separate and modularize while keeping the basic rule of OOP.
		
	</para>

	<para>
		For example, in system handling banking process, core concerns can be divided into deposit, withdrawal, money transfer,
		interest calculation, loan handling. These can be classified and modularized by core requirement and function, and 
		composing class and component type is possible under OOP.
		However, it is not true in reality. In reality, if the actual module has only the logic handling the relevant task, the module
		will be imperfect. First of all, the class handing each task and implemented method need to develop log for analyze or track future system,
		and need security check such as authorization and authentication check.
		In addition, sometimes Commit or Rollback function would be needed to be added when necessary.
		Log is needed in case that exception or problem occurs, which must be e-mailed to manager if needed.
		
	
	</para>

	<para>
		These additional functions can be implemented as independent class, but it is inevitable that codes which call and use those implemented functions
		must be included in the required domain in the core module.
		No matter how great OOP technology we use to make such functions independent to modularize and abstract as logging, authentication, authorization, 
		DB integration, transaction, locking, error handling, etc., parts related to all classes and methods of core modules are settled deeply and significantly.
		
	</para>

	<mediaobject>
		<imageobject>
			<imagedata align="center"
				fileref="../image/foundation/spring/cross_concerns.jpg" />
		</imageobject>
	</mediaobject>

	<para>
		In fact, when we look at well-modularized application class, there are more parts related to additional functions and handling rather than those
		related to core functions. If we use other type of logging platform, which will change logging class and method and log message,
		developers will have to modify every log-related code in all classes one by one.
		If one or two log goes missing in an important class and if you encounter some problem in checking the result,
		it will be a huge task to re-check and find the problem itself.
		Application developed in such manner has some serious flaws.
	
	</para>

	<itemizedlist>
		<listitem>
			<para>
				<emphasis role="bold">Duplicate code</emphasis>
				: Problems of duplicate code is well-known in various modules made in copy-paste.
				In most applications which do not use AOP, however, it is hard to avoid duplicate code even by abstraction and refactoring.
				
			</para>
		</listitem>

		<listitem>
			<para>
				<emphasis role="bold">Dirty code</emphasis>
				: As codes related to crosscutting concerns are located in-between core function codes, code gets dirtier and readability weakens.
				In addition, it causes developers to make mistake or bug, leading to more difficulty in code maintenance.
			
			</para>
		</listitem>

		<listitem>
			<para>
				<emphasis role="bold">Reduced productivity</emphasis>
				: As application developers need to develop frequently-occurring crosscutting concerns with implemented code,
				focus on development weakens, which leads to the reduction of overall productivity.
				Besides, there is a limit to dividing and dispersing developers by module.
				
			</para>
		</listitem>

		<listitem>
			<para>
				<emphasis role="bold">Reduced reuse</emphasis>
				: Reuse, a merit of OOP, is significantly drops.
			</para>
		</listitem>

		<listitem>
			<para>
				<emphasis role="bold">Difficulty in change</emphasis>
				: In case that new requests significantly affect on many parts,
				it becomes hard to apply new requests.
				In addition, advent of new concern of applying the concern becomes more difficult. 
			
			</para>
		</listitem>
	</itemizedlist>

	<para>
		<emphasis role="bold">Main AOP tools</emphasis>
	</para>

	<para>As AOP is similar to OOP extension, it does not have its exclusive language or independent development tool.
	Instead, it can be used in the format of language extension which extended existing OOP or in the format of tool or framework.
	One good example is AspectJ of Eclipse project, which was the origin of AOP development.
	AspectJ was developed in Zerox PARC lab in the beginning, then was donated to Eclipse project in 2002,
	and is currently developed and used with full support of IBM.
	In addition, there is AspectWerkz, which is developed mainly by BEA.
	Unlike AspectJ, AspectWerkz can use AOP without extending Java language itself but using existing Java language.
	Another AOP is SpringAOP, well-known for DI(Dependency Injection, hereinafter "DI")-based framework.
	The latest AOP is JBossAOP, which is considered representative intercepter method along with Spring AOP.

	</para>

	<informaltable>
		<tgroup cols="5">
			<thead>
				<row>
					<entry />

					<entry align="center">AspectJ</entry>

					<entry align="center">AspectWerkz</entry>

					<entry align="center">JBossAOP</entry>

					<entry align="center">SpringAOP</entry>
				</row>
			</thead>

			<tbody>
				<row>
					<entry align="center">Release</entry>

					<entry align="center">2001</entry>

					<entry align="center">2002</entry>

					<entry align="center">2004</entry>

					<entry align="center">2004</entry>
				</row>

				<row>
					<entry align="center">Version </entry>

					<entry align="center">1.2.1</entry>

					<entry align="center">2.0</entry>

					<entry align="center">1.3.0</entry>

					<entry align="center">1.2.5</entry>
				</row>

				<row>
					<entry align="center">Aspect declaration</entry>

					<entry>Exclusive code</entry>

					<entry>XML, Annotation</entry>

					<entry>XML, Annotation</entry>

					<entry>XML</entry>
				</row>

				<row>
					<entry align="center">Advice</entry>

					<entry align="center">Exclusive code</entry>

					<entry align="center">Java method</entry>

					<entry align="center">Java method</entry>

					<entry align="center">Java method</entry>
				</row>

				<row>
					<entry align="center">JoinPoint</entry>

					<entry>Method, constructor, Advice, Field Access, Instance</entry>

					<entry>Method, constructor, Advice, Field Access, Instance</entry>

					<entry>Method, constructor, Advice, Field Access, Instance</entry>

					<entry>Method</entry>
				</row>

				<row>
					<entry align="center">Pointcut matching</entry>

					<entry>Signature, WildCard, Annotation</entry>

					<entry>Signature, WildCard, Annotation</entry>

					<entry>Signature, WildCard, Annotation</entry>

					<entry>Regular expression</entry>
				</row>

				<row>
					<entry align="center">Weaving</entry>

					<entry>Compile and loading time, Byte code creation</entry>

					<entry>Compile and loading time, Byte code creation</entry>

					<entry>Runtime interception and Proxy</entry>

					<entry>Runtime interception and Proxy</entry>
				</row>

				<row>
					<entry align="center">IDE support</entry>

					<entry>Eclipse, JDeveloper, JBuilder, NetBeans</entry>

					<entry>Eclipse, NetBeans</entry>

					<entry>Eclipse</entry>

					<entry />
				</row>
			</tbody>
		</tgroup>
	</informaltable>

	<itemizedlist>
		<listitem>
			<para>
				<emphasis role="bold">AspectJ</emphasis>
			</para>

			<para>
				The core function of Aspect J that differentiate itself from other AOP tools is that 
				it is a structure made by extension of Java language.
				By using keyword named 'aspect', it can make Aspect, Pointcut, or Advice just like using new AOP language.
				Therefore, special AOP compiler, not general Java compiler, is needed.
				However, as the binary made in such manner can work at standard JVM, it can be executed without the support of special class loader.
				AspectJ is the longest and most frequently used AOP tool.
				At the same time, as it has the richest functions and excellent scalability, 
				it is considered to be the most ideal AOP tool.
				However, as it extended Java language, it is needed to understand new grammar and language.
				Also, when building project, special compiler must be used, which causes inconvenience.
				As weaving occurs when compiling, all classes selected by pointcut
				must be re-compiled every time aspect is changed.
			
			</para>
		</listitem>

		<listitem>
			<para>
				<emphasis role="bold">AspectWerkz</emphasis>
			</para>

			<para>
				Unlike AspectJ, AspectWerkz does not extend Java language. 
				Therefore, AOP can be implemented by using standard Java class.
				Unlike Advice when can be easily implemented by using generic class and method,
				pointcut which needs complicated grammar can be defined by using separate xml file.
				For developers familiar with approach to Java class and xml definition file, this can be very convenient.
				Recently, JDK5 support enabled the use of annotation, providing further convenience.
				Weaving uses loading time byte code which uses special class loader.
				It provides various JointPoiint and AOP functions like AspectJ, and IDE Plugin is developed for convenient development.
			
			</para>
		</listitem>

		<listitem>
			<para>
				<emphasis role="bold">JBossAOP</emphasis>
			</para>

			<para>
				JBossAOP basically works at container but can also be used at Java program irrelevant to container.
				However, the main purpose is to applying AOP to JBoss server and EJB3 Container to come.
				Like AspectWerkz, Advice is developed in standard Java code, and Pointcut and other definition 
				can be defined in xml file or JDK5 Annotation.
				So far, this has been used by some JBoss users.
				In the future, however, it is expected that its usage is expected to be increased 
				as POJO-based Enterprise Middleware Framework central to EJB3
				is developed. 
			
			</para>
		</listitem>

		<listitem>
			<para>
				<emphasis role="bold">SpringAOP</emphasis>
			</para>

			<para>
				SpringAOP is one of core functions of Spring Framework and is mainly used at Enterprise service working at container
				after Dependency Injection(hereinafter,"DI") of Spring.
				Unlike other AOP, SpringAOP performs AOP function in a Proxy method.
				As a result, it supports very limited parts compared with other AOP functions.
							
				However, as the purpose of SpringAOP implementation is to make the benefit of AOP merits 
				in addition to the core functions mainly used in Enterprise application and use them in Spring,
				there is no need to use all complicated AOP functions like other AOPs.
				Proxy-based SpringAOP is deeply connected to SpringIoC/DI.				
			
				Therefore, SpringAOP can be easily used by defining ProxyBean in Spring.						
				As only standard functions of JDK are used, there is no special build process or other troublesome tasks such as changing class loader.							
				Instead, although the type is JoingPoit is limited to method-based, main AOP functions needed at Enterprise application
				can be handled well enough based on method calling.
				Therefore, despite its limited AOP functions of SpringAOP,
				it is one of the fastest AOP solutions that are applied in the field.
				
				SpringAOP can develop both Advice and Pointcut with standard Java class.
				If needed pointcut can be expressed in regular expression by using  Pointcut FactoryBean in Pointcut definition file.
				The weakest point of SpringAOP is complicated proxy definition structure.
				It is more complicated even than other xml-based AOP defining proxy in Spring Bean definition file.
				In this case, if you use AutoProxyingCreatorBean supported by SpringAOP, it becomes possible to develop setting code very simply.
				
			</para>
		</listitem>
	</itemizedlist>


	<section id="foundation_spring_aop_components">
		<title>AOP components</title>

		<para>There are many newly-coined words.
		Among them, in particular, it is needed to clearly understand main components for development using AOP.
	
		</para>

		<section id="foundation_spring_aop_components_jointpoint">
			<title>JointPoint</title>

			<para>
				Refers to specific location which can be executed by inserting and running Crosscutting Concerns module.
				For example, part where method is called or returned can be one JointPoint.
				Another good examples are part where field is accessed, instance is created or exception is thrown.
				In Each JoinPoint, Crosscutting Concerns are automatically added by AOP before/after the JoinPoint,
				thereby becoming candidate to work. 
				
			</para>
		</section>

		<section id="foundation_spring_aop_components_pointcut">
			<title>Pointcut</title>

			<para>
				Pointcut refers to a function to decide what JoinPoint to use.
				As AOP does not use all JoinPoint of all module, it is needed to set specific JoinPoint to use if needed.
				Rules can be defined by using the following Pattern Matching as sort of JoinPoint selecting rule.
			</para>


			<section id="foundation_spring_aop_components_pointcut_patternmatching">
				<title>Pattern Matching Examples</title>

				<orderedlist>
					<listitem>
						<para>
							<emphasis role="bold">Basics</emphasis>
						</para>

						<itemizedlist>
							<listitem>
								<para>
									<emphasis role="bold">set*(..) </emphasis>
									: all method name beginning with 'set'
									
								</para>
							</listitem>

							<listitem>
								<para>
									*
									<emphasis role="bold">main(..)</emphasis>
									: main method of which return type is 'any type' and which has 'any type parameter'
		
								</para>
							</listitem>
						</itemizedlist>
					</listitem>

					<listitem>
						<para>
							<emphasis role="bold">Matching Type</emphasis>
						</para>

						<itemizedlist>
							<listitem>
								<para>
									<emphasis role="bold">java.io.</emphasis>
									* : all elements which belong to java.io package						
								</para>
							</listitem>

							<listitem>
								<para>
									<emphasis role="bold">org.myco.myapp..</emphasis>
									* :	all elements which belong to org.myco.myapp package or sub-package								
								</para>
							</listitem>

							<listitem>
								<para>
									<emphasis role="bold">Number+</emphasis>
									: Number of sub-type of number. (e.g.: Integer, Float, Double ..)								
								</para>
							</listitem>

							<listitem>
								<para>
									<emphasis role="bold">!(Number+)</emphasis>
									: all types which are not number of sub-type of number							
								</para>
							</listitem>

							<listitem>
								<para>
									<emphasis role="bold"><![CDATA[org.xyz.myapp..* &&
									!Serializable+ ]]></emphasis> : all elements which exist in org.xyz.myapp package or sub-package
									and are not Serializable type.
									
								</para>
							</listitem>

							<listitem>
								<para>
									<emphasis role="bold">int || Integer</emphasis>
									: int or Integer type
								</para>
							</listitem>
						</itemizedlist>
					</listitem>

					<listitem>
						<para>
							<emphasis role="bold">Matching Modifiers</emphasis>
						</para>

						<itemizedlist>
							<listitem>
								<para>
									<emphasis role="bold">public static void
										main(..)</emphasis>
									: public static void main method which has zero or more 'any type parameter'
						
								</para>
							</listitem>

							<listitem>
								<para>
									<emphasis role="bold">!private</emphasis>
									* *
									<emphasis role="bold">(..)</emphasis>
									: method whose modifier is not private
									among all the methods whose return type is 'any type' and which have zero or more 'any type parameter',
									
								
								</para>
							</listitem>

							<listitem>
								<para>
									*
									<emphasis role="bold">main(..) </emphasis>
									: If modifier is not specified separately, it means any modifier which is not default modifier
								
								</para>
							</listitem>
						</itemizedlist>
					</listitem>

					<listitem>
						<para>
							<emphasis role="bold">Matching Parameter</emphasis>
						</para>

						<itemizedlist>
							<listitem>
								<para>
									*
									<emphasis role="bold">main(*)</emphasis>
									: main method whose return type is 'any type' and has one or more 'any type parameter'
								
								</para>
							</listitem>

							<listitem>
								<para>
									*
									<emphasis role="bold">main(*,..)</emphasis>
									: all methods whose return type is 'any type' and which has one or more 'any type parameter'.
								
								</para>
							</listitem>

							<listitem>
								<para>
									*
									<emphasis role="bold">main(*,..,String,*)</emphasis>
									: main method whose return type is 'any type' and has three or more 'any type parameter' while second last
									parameter is is String.
								
								</para>
							</listitem>
						</itemizedlist>
					</listitem>

					<listitem>
						<para>
							<emphasis role="bold">Matching Constructor</emphasis>
						</para>

						<itemizedlist>
							<listitem>
								<para>
									<emphasis role="bold">new(..)</emphasis>
									: Constructor with one or more 'any type parameter'
								
								</para>
							</listitem>

							<listitem>
								<para>
									<emphasis role="bold">Account.new(..)</emphasis>
									: Constructor of Account class which has zero or more 'any type parameter'
							
								</para>
							</listitem>
						</itemizedlist>
					</listitem>
				</orderedlist>

				<para>AspectJ provides various Pointcut Designator that can specify Pointcut.
				Now, let's take a look at how to define pointcut by Pointcut Designator by using above-mentioned Pattern Matching approach.
				</para>
			</section>

			<section id="foundation_spring_aop_components_pointcut_designators">
				<title>Pointcut Designators</title>

				<orderedlist>
					<listitem>
						<para>
							<emphasis role="bold">execution or call</emphasis>
						</para>
						<para>Defines JoinPoint for executing specific method or constructor. Can match specific method
							name, parameter types, return type, declared exceptions, declaring
							type, modifiers of JoinPoint.
							But, must define return type pattern, method
							name pattern, parameter list pattern.
							The following is an example of defining pointcut using execution, call.
					</para>

						<itemizedlist>
							<listitem>
								<para>
									<emphasis role="bold">execution(* main(..))</emphasis>
									: when executing main method whose return type is 'any type' and which  has zero or more 'any type parameter'
									
								</para>
							</listitem>

							<listitem>
								<para>
									<emphasis role="bold">call(Account.new(..))</emphasis>
									: when calling constructor of Account class which has 'any type parameter'
									
								</para>
							</listitem>
						</itemizedlist>
					</listitem>

					<listitem>
						<para>
							<emphasis role="bold">get or set</emphasis>
						</para>

						<para>Defines JoinPoint for accessing/modifying specific field.
					</para>

						<itemizedlist>
							<listitem>
								<para>
									<emphasis role="bold">get(Collection +
										org.xyz.myapp..*.*) </emphasis>
									: when calling getter of any field which belongs to org.xyz.myapp package of Collection type.
								
								</para>
							</listitem>

							<listitem>
								<para>
									<emphasis role="bold">set(!private *
										Account+.*)</emphasis> : when calling setter for non-private field of Account type
										
								</para>
							</listitem>
						</itemizedlist>
					</listitem>

					<listitem>
						<para>
							<emphasis role="bold">handler</emphasis>
						</para>

						<para>Defines JoinPoint for Exception handling.
					</para>

						<itemizedlist>
							<listitem>
								<para>
									<emphasis role="bold">handler(DataAccessException)</emphasis>
									: matches
									cach(DataAccessException){...} and doesn't match
									catch(RuntimeException)
								</para>
							</listitem>

							<listitem>
								<para>
									<emphasis role="bold">handler(RuntimeException+)
        			       	 </emphasis>
									: matches both
								</para>
							</listitem>
						</itemizedlist>
					</listitem>

					<listitem>
						<para>
							<emphasis role="bold">within</emphasis>
						</para>
						<para><![CDATA[Defines JoinPoint which belongs to specific type and usually used in format with &&, ||, !, etc.
						]]></para>

						<itemizedlist>
							<listitem>
								<para>
									<emphasis role="bold">within(*)</emphasis>
									: matches any JoinPoint
								</para>
							</listitem>

							<listitem>
								<para>
									<emphasis role="bold">within(org.xyz.myapp..*)</emphasis>
									: all elements which belong to org.xyz.myapp package
								</para>
							</listitem>

							<listitem>
								<para>
									<emphasis role="bold">within(IInterface+)</emphasis>
									: all elements of IInterface type
								</para>
							</listitem>
						</itemizedlist>
					</listitem>

					<listitem>
						<para>
							<emphasis role="bold">withincode</emphasis>
						</para>
						<para>Defines Joinpoint for code defined within the relevant method or constructor.
						</para>

						<itemizedlist>
							<listitem>
								<para>withincode(!void get*()) : code whose return type is not 'void' and method name begins with 'get'
								and where there is no parameter.
								</para>
							</listitem>
						</itemizedlist>
					</listitem>

					<listitem>
						<para>
							<emphasis role="bold">args</emphasis>
						</para>
						<para>Defines JoinPoint about the number of input value, type, etc.
						</para>

						<itemizedlist>
							<listitem>
								<para>
									<emphasis role="bold"><![CDATA[call(* transfer(..)) &&
										args(DepositAccount,CheckingAccount,*)]]></emphasis>
									: when calling method whose method name is 'transfer' and the number of input parameter is two or more,
									and the type of the first and second parameter is 'DepositAccoun and 'CheckingAccount'
									
								</para>
							</listitem>
						</itemizedlist>
					</listitem>

					<listitem>
						<para>
							<emphasis role="bold">this</emphasis>
						</para>
						<para>Defines the type of object which has JoinPoint. (Runtime type)</para>
						<itemizedlist>
							<listitem>
								<para>
									<emphasis role="bold">this(Account)</emphasis>
									: all JoinPoint of class (Proxy) which implemented interface account.
								</para>
							</listitem>
						</itemizedlist>
					</listitem>

					<listitem>
						<para>
							<emphasis role="bold">target</emphasis>
						</para>
						<para>Defines the type of target object which has JoinPoint.(Runtime type)
						</para>

						<itemizedlist>
							<listitem>
								<para>
									<emphasis role="bold"><![CDATA[call(* *(..)) &&	target(Account)]]></emphasis>
									: when calling all methods within Account class.
								</para>
							</listitem>
						</itemizedlist>
					</listitem>
				</orderedlist>

				<para>
					As Spring supports AOP for method call only, 
					only execution, within, target, this, args can be used among the above-mentioned various Pointcut Designators.
				
        			</para>
			</section>
		</section>
		
		<section id="foundation_spring_aop_components_advice">
      	<title>Advice</title>

      		<para>
	      		Advice is a code that can be inserted into each JoinPoint and run,
	      		and runtime is before/after JoinPoint when pointcut is matched.
	      		Can be selected among  <emphasis role="bold">before, after, after
	      		returning, after throwing, around </emphasis>.
	      	
      		</para>

      	<informaltable>
        <tgroup cols="2">
        <colspec colnum="1" colname="col1" colwidth="2*" />
			<colspec colnum="2" colname="col2" colwidth="8*" />
			<tbody>
				<row>
					<entry align="center">Before</entry>
					<entry>Before Advice is an advice that runs before matched JoinPoint.
				</entry>
				</row>
		
				<row>
					<entry align="center">After</entry>
		
					<entry>
						After Advice can be divided into after (finally), after returning, after throwing depending on the time of running. 
					
						<itemizedlist>
							<listitem>
								<para>after returning : advice that runs after JoinPoint is successfully returned.
							</para>
							</listitem>
		
							<listitem>
								<para>after throwing : advice that runs after matched JoinPoint is finished as exception occurred.
							</para>
							</listitem>
		
							<listitem>
								<para>after (finally) : advice that runs after matched PoinPoint is finished. Rarely used.
								</para>
							</listitem>
						</itemizedlist>
					</entry>
				</row>

            	<row>
              		<entry align="center">Around</entry>

		            <entry>
		            	As the strongest advice, which runs before/after matched JoinPoint and can decide the execution time of JoinPoint.
		            	In addition, unlike other advice, this advice can change input value, target object, return value, etc.
		            
              		</entry>
            	</row>
          	</tbody>
        </tgroup>
     	</informaltable>

    	<para>
    	 	<![CDATA[For details on how to define advice by the time of running, under Manual >> Foundation Plugin >> Spring >> AOP ]]>, refer to <link
      		linkend="foundation_spring_aop_annotation">Annotation based AOP</link> , <link
      		linkend="foundation_spring_aop_xmlbasedaop">XML based AOP</link> , <link
      		linkend="foundation_spring_aop_aspectj">AspectJ based AOP</link>.
      	</para>
    	</section>
    	
    	<section id="foundation_spring_aop_components_weaving">
      	<title>Weaving or CrossCutting</title>

      	<para>
      		For AOP to run necessary function without directly touching the code of Core Concerns module, 
      		special task called 'Weaving' or 'Crosscutting' is needed.
      		Instead that Core Concerns module search and use Crosscutting Concerns module they need,
      		AOP makes Crosscutting Concerns they need in-between Crosscutting modules run and weave through Weaving process.
      		That way, AOP can effectively apply Crosscutting Concerns function they need without the need of modifying existing OOP-based codes. 
    
      	</para>

      	<mediaobject>
        	<imageobject>
         		<imagedata align="center" fileref="../image/foundation/spring/weaving.jpg" />
        	</imageobject>
      	</mediaobject>

      	<para>
      		Weaving was not easily implemented in existing Java language or complier.
      		It was not until late-1990s that AOP technology appeared in earnest when Gergor Kiczales at Zerox PARC lab developed AspectJ.
      	
      	</para>

      	<para>There are three ways of handling Weaving as the following.
      	</para>

      	<informaltable>
		<tgroup cols="2">
		<colspec colnum="1" colname="col1" colwidth="3*" />
		<colspec colnum="2" colname="col2" colwidth="7*" />
		<thead>
			<row>
				<entry align="center">Weaving method</entry>

				<entry align="center">Explanation</entry>
			</row>
		</thead>

		<tbody>
			<row>
				<entry>
					<emphasis role="bold">Compiletime Weaving</emphasis>
				</entry>

				<entry>
					Refers to the method in which Crosscutting Concerns codes made in Aspect format are inserted in-between Core Concerns 
					and final binary which Aspect is applied to is created, through separate compiler.
			
					(ex. AspectJ, ...)
				</entry>
			</row>

			<row>
				<entry>
					<emphasis role="bold">Loadingtime Weaving</emphasis>
				</entry>

				<entry>
					Modifies binary information of the relevant class when JVM loads class by using separate agent.
					In other words, agent support AOP by providing binary code inserted with Crosscutting Concerrns code. (ex. AspectWerkz, ...)
					
				</entry>
			</row>

			<row>
				<entry>
					<emphasis role="bold">Runtime Weaving</emphasis>
				</entry>

				<entry>Refers to the method supporting AOP by using Proxy without modifying source code or binary file.
				Object which implemented Core Concerns through Proxy is accessed through Proxy, which executes Cross Concerns
				before/after executing Core Concerns.
				Therefore, in the case of Proxy-based Runtime Weaving, there is a limit that AOP can be applied to calling method.(ex. Spring AOP, ...)
			</entry>
			</row>
		</tbody>
		</tgroup>
		</informaltable>
    	</section>
    	
    	<section id="foundation_spring_aop_components_aspect">
      	<title>Aspect</title>

      		<para>
      			Aspect is a combination of where(Pointcut) and what(Advice).
      			In the AOP which extended Java language like AspectJ, Aspect can be developed in code just like Java class.
      			The following is a part of (after
      			returning advice) Aspect HelloFromAspectJ, which leaves "Hello from AspectJ" string after executing (pointcut main())main method of all classes.
      			
      		</para>

            <programlisting language="java">public aspect HelloFromAspectJ{
    // define pointcut
    pointcut main(): execution(public static void main(String[]));
    // define advice
    after() returning : main() {
        System.out.println("Hello from AspectJ!");
    }
}</programlisting>

      		<para>
      			<![CDATA[For details on how to define Aspect, refer to, under Manual>> Foundation Plugin >> Spring >>]]> AOP, <link
      			linkend="foundation_spring_aop_annotation">Annotation based AOP</link> , <link
      			linkend="foundation_spring_aop_xmlbasedaop">XML based AOP</link> , <link
      			linkend="foundation_spring_aop_aspectj">AspectJ based AOP</link>.
      		</para>
    	</section>
	</section>
	
	<section id="foundation_spring_aop_annotation">
    <title>Annotation based AOP</title>

    	<para>
    		Now, let's take a look at how to define and test Aspect by using  @AspectJ(Annotation), among main AOP tools.
    		@AspectJ(Annotation) is an annotation newly added at AspectJ 5 version.
    		From Spring 2.0, handling such annotations are possible.
    		Therefore, if Spring-based, @AspectJ(Annotation)-based AOP application is possible without separate Compiler or Weaver.
    		In addition, when defining Aspect using annotation, as there is no need of defining xml file, Aspect application becomes much simpler.
    		(But, note that annotation can be defined from JAVA 5.)
    		
    	</para>
    	
    	<section id="foundation_spring_aop_annotation_configuration">
      	<title>Configuration</title>

      		<para>
      			To execute Pointcut, Advice defined in the relevant class by loading @AspectJ(Annotation)-applied classes,
      			add the following to Spring configuration xml file.
      		 
      			<programlisting language="xml"><![CDATA[<aop:aspectj-autoproxy/>]]></programlisting>
      		</para>
    	</section>
    	
    	<section id="foundation_spring_aop_annotation_apsect">
      	<title>@Aspect definition</title>

      		<para>
      			Defines that specific class is 'Aspect' by using @Aspect.
      			The following LoggingAspect shows that the relevant class is 'Aspect' by using @Aspect.
      		
      			<programlisting language="java"><emphasis role="bold">@Aspect</emphasis>
public class LoggingAspect {
      //...
}</programlisting>
     		</para>
    	</section>
    	
    	<section id="foundation_spring_aop_annotation_pointcut">
      	<title>@Pointcut definition</title>

      		<para>
      			Defines the part to apply the relevant Aspect by using @Pointcut.
      			(When defining pointcut, refer to <link linkend="foundation_spring_aop_components_pointcut"> How to use Pointcut Designator and Pattern
      			Matching</link>.)
      			The following is the part defining Pointcut of PrintStringUsingAnnotation.
      			@Pointcut was defined as "execution(* *..GenericService+.*(..))" and method name of serviceMethod was assigned
      			as an identifier of the relevant Pointcut.
      			This means that all the execution part of the method whose class name ends with 'GenericService' is Pointcut to apply Aspect.
      			The relevant pointcut can be used under the name of serviceMethod().
      		
				<programlisting language="java"><emphasis role="bold">@Pointcut</emphasis>("execution(* *..GenericService+.*(..))")
public void serviceMethod(){}</programlisting>	
      		</para>
    	</section>
    	
    	<section id="foundation_spring_aop_annotation_advice">
      	<title>@Advice definition</title>

      		<para>Let's take a look at how to define Advice by the time of running by using annotation.
      		</para>

      		<section id="foundation_spring_aop_annotation_advice_before">
        	<title>Before Advice</title>

        		<para>
        			Defines Before Advice by using @Before.
        			The following is the part defining Before Advice. 
        			beforeLogging(), Before Advice, plays a role of showing method name and class name
        			with "Logging Aspect : executed " string and the relevant pointcut before above-mentioned serviceMethod() Pointcut.
        		
				<programlisting language="java"><emphasis role="bold"><![CDATA[@Before("serviceMethod()")]]></emphasis><![CDATA[
public void beforeLogging(JoinPoint thisJoinPoint) {
    Class clazz = thisJoinPoint.getTarget().getClass();
    String className = (thisJoinPoint.getTarget().getClass().getName()).toLowerCase();
    String methodName = thisJoinPoint.getSignature().getName();
    StringBuffer buf = new StringBuffer();
   
    buf.append("\n** Logging Aspect : executed " + methodName + "() in " + className + " Class.");
    Object[] arguments = thisJoinPoint.getArgs();
    
    if (arguments.length > 0) {
        for (int i = 0; i < arguments.length; i++) {
        buf.append("\n*************" + arguments[i].getClass().getName() 
                + "*************\n");
        buf.append(arguments[i].toString());
        buf.append("\n*******************************************\n");
        }
    } else
         buf.append("\nNo arguments\n");

    Log logger = LogFactory.getLog(clazz);
    if (logger.isDebugEnabled())
        logger.debug(buf.toString());
}]]></programlisting>
         		</para>
        		<para>
        			beforeLogging() has one input parameter(JoinPoint) and includes target information such as target class name and method name, etc.
        			In the case of advice which requires no target information, there is no need to declare input parameter of JoinPoint.
        			</para>
      		</section>
      
      		<section id="foundation_spring_aop_annotation_advice_afterreturning">
        	<title>AfterReturning Advice</title>

        		<para>
        			Defines AfterReturning Advice by using @AfterReturning.
        			The following is a part of defining AfterReturning Advice and defines that the execution result of the relevant pointcut
        			is contained in 'retVal' variable.
        			afterReturningExecuteGetMethod(),AfterReturning Advice, plays a role showing class name and method name with "AfterReturning
        			Advice of PrintStringUsingAnnotation" string and the relevant pointcut after above-mentioned pointcut.
        			 <programlisting language="java">@<emphasis
              		role="bold">AfterReturning(pointcut = "serviceMethod()", returning = "retVal")</emphasis>
public void afterReturningExecuteGetMethod(JoinPoint thisJoinPoint, Object <emphasis role="bold">retVal</emphasis>) {
    Class targetClass = thisJoinPoint.getTarget().getClass();
    Signature signature = thisJoinPoint.getSignature();
    String opName = signature.getName();
   
    System.out.println("AfterReturning Advice of PrintStringUsingAnnotation");
    System.out.println("***" + targetClass + "." + opName + "()" + "***");
}</programlisting>
          		</para>

		        <para>
		        	afterReturningExecuteGetMethod() has two input parameters (JoinPoint, Object), the first of which contains target information
		        	such as target class name and method, etc. and the second one is the execution result of the relevant pointcut.
		        	If the execution result of specific pointcut is needed in AfterReturning Advice,
		        	define returning value and define the same input parameter name for the relevant method when defining Advice.
		        	Each input parameter can be selectively defined based on the need of definition of AfterReturning Advice.
		        
        		</para>
      		</section>

      		<section id="foundation_spring_aop_annotation_advice_afterthrowing">
        	<title>AfterThrowing Advice</title>

        	<para>
        		Defines AfterThrowing Advice by using @AfterThrowing.
        		The following defines AfterThrowing Advice of transfer,
        		and defines to contain Exception object occurred when executing the relevant pointcut in  variable of 'exception'.
        		serviceMethod(), AfterThrowing Advice, handles exception after exception occurs at the above-mentioned pointcut,
        		and shows exception message depending on the type of exception.
        		
        		<programlisting language="java"><emphasis 
        		role="bold">@AfterThrowing(pointcut = "serviceMethod()", throwing = "exception")</emphasis>
public void transfer(JoinPoint thisJoinPoint, Exception exception) throws SalesException {
    Object target = thisJoinPoint.getTarget();
    while (target instanceof Advised) {
    try {
        target = ((Advised) target).getTargetSource().getTarget();
    } catch (Exception e) {
        LogFactory.getLog(this.getClass()).error("Fail to get target object
                    from JointPoint.", e);
        break;
        }
    }
	
    String className = target.getClass().getSimpleName().toLowerCase();
    String opName = (thisJoinPoint.getSignature().getName()).toLowerCase();
    Log logger = LogFactory.getLog(target.getClass());

    if (exception instanceof SalesException) {
        SalesException empEx = (SalesException) exception;
        logger.error(empEx.getMessage(), empEx);
        throw empEx;
    }
	
    if (exception instanceof BaseException) {
        BaseException baseEx = (BaseException) exception;
        logger.error(baseEx.getMessage(), baseEx);
        throw new SalesException(messageSource, "error." + className + "." + opName,
                        new String[] {}, exception);
    }		
	
    logger.error(messageSource.getMessage("error." + className + "."
                                        + opName, new String[] {}, "no messages",
                                        Locale.getDefault()),exception);
    throw new SalesException(messageSource, "error." + className + "." + opName,
                     new String[] {}, exception);
}</programlisting>
       		</para>

        	<para>
        		transfer() has two input parameters (JoinPoint, Exception), the first of which contains target information
		        such as target class name and method, etc. and the second one is the execution object occurred at executing pointcut.
		        If it is need to refer to exception occurred at executing specific pointcut at AfterThrowing Advice,
		        define throwing value and the same input parameter for the relevant method when defining Advice.
		        Each input parameter can be selectively defined based on the need of definition of AfterThrowing Advice .
		        
        		
        	</para>
      		</section>

      		<section id="foundation_spring_aop_annotation_advice_after(finally)">
        	<title>After(finally) Advice</title>

        		<para>
        			Defines After(finally) Advice by using @After.
        			The following defines After(finally) Advice of PrintStringUsingAnnotation.
        			afterExecuteGetMethod(), After(finally) Advice, plays a role of showing class name and method name with 
        			"After(finally) Advice of PrintStringUsingAnnotation" string and the relevant pointcut
        			after above-mentioned  getMethods() Pointcut.
        			
        			<programlisting language="java">@<emphasis role="bold">After("getMethods()")</emphasis>
public void afterExecuteGetMethod(JoinPoint thisJoinPoint) {
    Class targetClass = thisJoinPoint.getTarget().getClass();
    Signature signature = thisJoinPoint.getSignature();
    String opName = signature.getName();
    
    System.out.println("After(finally) Advice of PrintStringUsingAnnotation");
    System.out.println("***" + targetClass + "." + opName + "()" + "***");
}</programlisting>
           		</para>

        		<para>
        			afterExecuteGetMethod() has one input parameter(JoinPoint),
        			which has target information such as target class name, method name, etc.
        			In the case of advice which requires no target information, 
        			there is no need to declare 'JoinPoint' input parameter.
        		
        		
        		</para>
      		</section>

      		<section id="foundation_spring_aop_annotation_advice_around">
        	<title>Around Advice</title>

        		<para>
        			Defines Around Advice by using @Around.
        			The following defines Around Advice of PrintStringAroundUsingAnnotation.
        			aroundExecuteUpdateMethod(), Around
        			Advice, plays a role of showing class name and method name with "Around Advice of PrintStringUsingAnnotation" string
        			and the relevant pointcut after updateMethods() Pointcut.
        		
        			<programlisting language="java">@<emphasis role="bold">Around("updateMethods()")</emphasis>
public Object aroundExecuteUpdateMethod(ProceedingJoinPoint thisJoinPoint) throws Throwable {
    Class targetClass = thisJoinPoint.getTarget().getClass();
    Signature signature = thisJoinPoint.getSignature();
    String opName = signature.getName();
    
    System.out.println("Around Advice of PrintStringUsingAnnotation");
    System.out.println("***" + targetClass + "." + opName + "()" + "***");
   
    // before logic
    Object retVal = thisJoinPoint.proceed();
    // after logic
    
    return retVal;
}</programlisting>
           		</para>

        		<para>
        			aroundExecuteUpdateMethod() has one input parameter(ProceedingJoinPoint)
        			and can execute the target pointcut through calling method named 'proceed()'
        			and also contains target information such as target class name, method name, etc.
        			In other words, pre/post-process of pointcut is possible and also it is possible to decide
        			runtime of pointcut.
        			In addition, unlike other Advices, it is possible to modify input value, target, return value, etc.
        			In the case of Advice which requires no target information,
        			there is no need to declare 'ProceedingJoinPoint' input parameter.
        		
        		</para>
      		</section>
    	</section>
    	
    	<section id="foundation_spring_aop_annotation_runaspect">
      	<title>Aspect execution</title>

       		<para>
       			Now, let's check whether above-mentioned Aspect are working properly by using test code Main.java.
       			The following is main() method of test code Main.java, and checks whether LoggingAspect defined with Before Advice
       			works properly by performing CRUD logic on the actual product.
       			
				<programlisting language="java">public static void main(String[] args) throws Exception {
    Main main = new Main();
    // 1. initialize context
    main.setup();
    // 2. test
    main.manageProduct();
    // 3. close context
    main.teardown();
}

public void manageProduct() throws Exception {
    // 1. lookup productService, categoryService
    ProductService productService = (ProductService) context.getBean("productService");
      
    // 2. create a new product
    Product product = new Product();
    product.setProdNo("PRODUCT-99999");
    product.setProdName("sample.sportsone");
    product.setProdDetail("sports one detail");
    product.setSellerId("woos41");
    product.setAsYn("Y");
    product.setManufactureDay("20081225");
    product.setSellAmount(new Long(50));
    product.setSellQuantity(new Long(50));
    productService.create(product);

    // 3. get product list
    ProductSearchVO searchVO = new ProductSearchVO();
    searchVO.setSearchCondition("0");
    searchVO.setSearchKeyword("sample.sportsone");
    Page products = productService.getPagingList(searchVO);
    System.out.println("after creating a new product, product size is a '"
                    + products.getSize() + "'.");
    
    // 4. update a product
    product.setProdName("sportsone-update");
    product.setProdDetail("sports one detail-update");
    productService.update(product);

    // 5. get a product
    Product result = productService.get(product.getProdNo());
    System.out.println("after updating a product, product name is a '"
                    + result.getProdName() + "'.");

    // 6. remove a product
    productService.remove(product.getProdNo());

    // 7. get product list
    searchVO = new ProductSearchVO();
    searchVO.setSearchCondition("0");
    searchVO.setSearchKeyword("sample.sportsone");
    products = productService.getPagingList(searchVO);
    System.out.println("after creating a new product, product size is a '"
                    + products.getSize() + "'.");
}</programlisting>
			</para>

      		<para>
      			When executing first logic,productService.create(product);, LoggingAspect defined as Before Advice is applied,
      			and the execution result is shown in the console window as the following.
      		
				<programlisting
				 language="java">** Logging Aspect : executed initialize() in anyframe.sample.aop.sales.service.impl.productserviceimpl Class.
No arguments
** Logging Aspect : executed initialize() in anyframe.sample.aop.sales.service.impl.productserviceimpl Class.
No arguments</programlisting>
			</para>

      		<para>
      			When executing second logic, productService.getPagingList(searchVO);,LoggingAspect defined as before Advice is applied,
      			and the execution result is shown in the console window as the following.
      			
				<programlisting
				language="java">** Logging Aspect : executed getPagingList() in anyframe.sample.aop.sales.service.impl.productserviceimpl Class.
*************anyframe.sample.aop.sales.service.ProductSearchVO*************
 searchCondition - 0
 searchKeyword - sample.sportsone
 pageIndex - 1

*******************************************

** Logging Aspect : executed getPagingList() in anyframe.sample.aop.sales.service.impl.productserviceimpl Class.
*************anyframe.sample.aop.sales.service.ProductSearchVO*************
 searchCondition - 0
 searchKeyword - sample.sportsone
 pageIndex - 1

*******************************************

after creating a new product, product size is a '1'.</programlisting>
			</para>
    	</section>	
	</section>
	
	<section id="foundation_spring_aop_xmlbasedaop">
    <title>XML based AOP</title>

    	<para>
    		Now, let's take a look at how to define and test xml schema-based Aspect by using Spring AOP among main AOP tools.
    		From Spring 2.x version,  aop namespace, XML schema for AOP definition was added.
    	
    	</para>
    	
    	<section id="foundation_spring_aop_xmlbasedaop_aspect">
      	<title>Aspect definition</title>

      		<para>Defines Aspect by using <![CDATA[<aop:aspect>]]>, subtag of <![CDATA[<aop:config>]]>.
      		The following context-aspect.xml defines Aspect by using aop namespace.
      	
				<programlisting language="xml"><![CDATA[<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop-2.5.xsd">

    <bean id="methodLoggingAspect" class="anyframe.sample.common.aspect.LoggingAspect" />
    <bean id="exceptionTransfer" class="anyframe.sample.common.aspect.ExceptionTransfer">
        <property name="messageSource" ref="messageSource"/>
    </bean>
</beans>]]></programlisting>
			</para>

      		<para>
      			<![CDATA[By defining class which defines Advice as bean, and referring to the
      			relevant bean at <aop:aspect> in <aop:config>,
      			Aspect can be defined.
      		.]]>
      		</para>
    	</section>
    	
    	<section id="foundation_spring_aop_xmlbasedaop_pointcut">
      	<title>Pointcut definition </title>

  		    <para>Define pointcut by using Pointcut Designator and
     			Pattern Matching at expression value in  <![CDATA[<aop:pointcut>]]>.
     			And assign identifier to id value.
     			(When defining Pointcut, refer to
      			 <link linkend="foundation_spring_aop_components_pointcut">How to use Pointcut Designator and
      			Pattern Matching</link>.) 
  		 
		<programlisting language="xml"><![CDATA[<aop:pointcut id="serviceMethod" expression="execution(* *..GenericService+.*(..))" />]]></programlisting>
			</para>
      		<para>Defines pointcut that execution parts of all method whose class name ends with GenericService to apply Aspect to.
      		The relevant pointcut can be used under the name of serviceMethod.
      	
      		</para>
      	</section>
      	
      	<section id="foundation_spring_aop_xmlbasedaop_advice">
      	<title>Advice definition and implementation</title>

      		<para>Now, let's take a look at how to define and implement Advice by the time of running based on xml.
      		</para>

			<section id="foundation_spring_aop_xmlbasedaop_advice_before">
     	   	<title>Before Advice</title>

				<para>Defines Before Advice using <![CDATA[<aop:before>]]>.
				The following defines Before Advice of context-aspect.xml.
				Indicates that serviceMethod pointcut is referred to,
				and beforeLogging() method of 'methodLoggingAspect' bean must be called before the relevant pointcut.
		
        			<programlisting language="xml"><![CDATA[<aop:before method="beforeLogging" pointcut-ref="serviceMethod"/>]]></programlisting>
        		</para>

     		   	<para>
     		   		The following is a part of LoggingAspect class which implements Before Advice.
     		   		beforeLogging() , which performs Before Advice task, plays a role of showing class name and method name 
     		   		with the relevant pointcut before above-mentioned  serviceMethod Pointcut.
     		
   					<programlisting language="java"><![CDATA[public class LoggingAspect {
    public void ]]><emphasis role="bold"><![CDATA[beforeLogging]]></emphasis><![CDATA[(JoinPoint thisJoinPoint) {
        Class clazz = thisJoinPoint.getTarget().getClass();
        String className = (thisJoinPoint.getTarget().getClass().getName()).toLowerCase();
        String methodName = thisJoinPoint.getSignature().getName();
        StringBuffer buf = new StringBuffer();
		
        buf.append("\n** Logging Aspect : executed " + methodName + "() in " + className
                + " Class.");

        Object[] arguments = thisJoinPoint.getArgs();
        if (arguments.length > 0) {
            for (int i = 0; i < arguments.length; i++) {
                buf.append("\n*************" + arguments[i].getClass().getName()
                        + "*************\n");
                buf.append(arguments[i].toString());
                buf.append("\n*******************************************\n");
                }
        } else
            buf.append("\nNo arguments\n");

        Log logger = LogFactory.getLog(clazz);
        if (logger.isDebugEnabled())
            logger.debug(buf.toString());
    }
}]]></programlisting>
				</para>

        		<para>
        			beforeLogging() has one input parameter(JoinPoint) and has target information such as target class name,
        			method name, etc.
        			In the case of Advice which requires no target information, there is no need to declare 'JoinPoint' input parameter.
        		
        		</para>
      		</section>
      		
      		<section id="foundation_spring_aop_xmlbasedaop_advice_afterreturning">
        		<title>AfterReturning Advice</title>

        		<para>
        			Defines AfterReturning Advice by using <![CDATA[<aop:after-returning>]]>.
        			The following defines AfterReturning Advice of context-aspect.xml.
        			Indicates that above-mentioned 'serviceMethod' pointcut is referred to
        			and afterReturningExecuteGetMethod() method of 'printStringAspect' bean must be called after the relevant pointcut.
        			In addition, the execution result of the relevant pointcut is contained in the 'retVal' variable.
        		
        			<programlisting
        			language="xml"><emphasis role="bold"><![CDATA[<aop:after-returning>]]></emphasis> method="afterReturningExecuteGetMethod" returning="retVal" 
     pointcut-ref="serviceMethod" /></programlisting>
     			</para>

        		<para>
        			The following is a part of PrintStringUsingXML class which implements AfterReturning Advice.
        			AfterReturning Advice, which performs AfterReturning Advice role,
        			plays a role of showing class name and method name with "AfterReturning Advice of PrintStringUsingXML" string and the relevant 
        			pointcut after above-mentioned pointcut.
        			 <programlisting
        			language="java">public class PrintStringUsingXML {
	// ...
	
    public void <emphasis role="bold">afterReturningExecuteGetMethod(JoinPoint thisJoinPoint, Object retVal)</emphasis> {
        Class targetClass = thisJoinPoint.getTarget().getClass();
        Signature signature = thisJoinPoint.getSignature();
        String opName = signature.getName();
	
        System.out.println("AfterReturning Advice of PrintStringUsingXML");
        System.out.println("***" + targetClass + "." + opName + "()" + "***");
	}
	
	// ...
}</programlisting>
				</para>

        		<para>
        			afterReturningExecuteGetMethod() has two input parameters(JoinPoint, Object),
        			and the first of which has target information such as target class name, method name, etc. and the
        			second one is the execution result of the relevant pointcut.
        			If it is needed to refer to execution result of specific pointcut at AfterReturning Advice,
        			define returning value and the same input parameter of the relevant method when defining the relevant Advice in xml.
        			Each input parameter can be selectively defined depending on the need when defining AfterReturning Advice.
        			
        		</para>
      		</section>
      		
      		<section id="foundation_spring_aop_xmlbasedaop_advice_afterthrowing">
        	<title>AfterThrowing Advice</title>

        		<para>
        			Defines AfterThrowing Advice by using <![CDATA[<aop:throwing>.
        			The following defines AfterThrowing Advice of context-aspect.xml.
        			Indicates that above-mentioned 'serviceMethod' pointcut is referred, and 
        			tranfer()of exceptionTransfer
        			Bean tranfer() method must be called after the relevant pointcut.
        			In addtiion, exectpion which occured at executing the relevant pointcut must be 'exception' variable
        			and be same to the input parameter of the relevant Advice. ]]>
        			<programlisting language="xml"><![CDATA[<aop:after-throwing throwing="exception" pointcut-ref="serviceMethod" method="transfer" />]]></programlisting>
        		</para>

        		<para>
        			The following is a part of ExceptionTransfer which implements AfterThrowing Advice.
        			transfer(), which performs AfterThrowing Advice task, plays a role of showing error message
        			after exception occurs at above-mentioned pointcut. 
        		
        			<programlisting language="java">public class ExceptionTransfer {

    private MessageSource messageSource;

    public void setMessageSource(MessageSource messageSource) {
        this.messageSource = messageSource;
    }	

    public void transfer(JoinPoint thisJoinPoint, Exception exception) throws SalesException {
        Object target = thisJoinPoint.getTarget();
        while (target instanceof Advised) {
            try {
                target = ((Advised) target).getTargetSource().getTarget();
            } catch (Exception e) {
                LogFactory.getLog(this.getClass()).error(
                    "Fail to get target object from JointPoint.", e);
                break;
            }
        }

        String className = target.getClass().getSimpleName().toLowerCase();
        String opName = (thisJoinPoint.getSignature().getName()).toLowerCase();
        Log logger = LogFactory.getLog(target.getClass());

        if (exception instanceof SalesException) {
            SalesException empEx = (SalesException) exception;
            logger.error(empEx.getMessage(), empEx);
            throw empEx;
        }
		
        if (exception instanceof BaseException) {
            BaseException baseEx = (BaseException) exception;
            logger.error(baseEx.getMessage(), baseEx);
            throw new SalesException(messageSource, "error." + className + "."
                    + opName, new String[] {}, exception);
        }		

        logger.error(messageSource.getMessage("error." + className + "."
                + opName, new String[] {}, "no messages", Locale.getDefault()), exception);

        throw new SalesException(messageSource, "error." + className + "."
                + opName, new String[] {}, exception);
    }
}</programlisting>
				</para>

        		<para>
        			transfer() has two input parameters((JoinPoint, Exception), and the first of which
        			contains target information such as target class name, method name, etc. and the second one
        			 is an exception object occurred at executing pointcut.
        			 If it is needed to refer to exception occurred when executing specific pointcut at AfterThrowing Advice,
        			 define throwing value when defining the relevant Advice in xml and make the input parameter name of the relevant method identical.
        			 Each input parameter can be selectively defined depending on the need when defining AfterThrowing Advice.
        			
        		</para>
    		</section>
    		
    		<section id="foundation_spring_aop_xmlbasedaop_advice_after(finally)">
        	<title>After(finally) Advice</title>

        		<para>
        		Defines After(finally) Advice by using <![CDATA[<aop:after>.
        		The following defines After(finally) Advice of context-aspect.xml.
        		Indicates that above-mentioned 'getMethods' pointcut is referred to
        		and that it is needed to call afterExecuteGetMethod() method of 'printStringAspect' bean after the relevant pointcut.]]>
        		<programlisting language="xml"><emphasis role="bold"><![CDATA[<aop:after]]></emphasis> method="afterExecuteGetMethod" pointcut-ref="getMethods"></programlisting>
        		</para>

        		<para>
        			The following is a part of PrintStringUsingXML class which implements After(finally) Advice.
        			afterExecuteGetMethod(), which performs After(finally) Advice role, plays a role of showing class name
        			and method name with "After(finally) Advice of PrintStringUsingXML" string and the relevant pointcut
        			after above-mentioned ' getMethods()'pointcut.
      
        			<programlisting language="java">public class PrintStringUsingXML {
	// ...
	
    public void afterExecuteGetMethod(JoinPoint thisJoinPoint) {
        Class targetClass = thisJoinPoint.getTarget().getClass();
        Signature signature = thisJoinPoint.getSignature();
        String opName = signature.getName();

        System.out.println("After(finally) Advice of PrintStringUsingXML");
        System.out.println("***" + targetClass + "." + opName + "()" + "***");
    }
	
    // ...
}</programlisting>
				</para>

      			<para>
      				afterExecuteGetMethod() has one input parameter(JoinPoint) which contains target information
      				such as target class name, method name, etc.
      				In the case  of advice which requires no target information, 
      				there is no need to declare 'JoinPoint' input parameter.
    
        		</para>
  		    </section>
  		    
  		    <section id="foundation_spring_aop_xmlbasedaop_advice_around">
        	<title>Around Advice</title>

        		<para>
        			Defines Around Advice by using <![CDATA[<aop:around>.
        			The following defines Around Advice of context-aspect.xml.
        			Indicates that 'updateMethods' pointcut is referred to, and that 
        			it is needed to call aroundExecuteGetMethod() method of 'printStringAspect' bean 
        			after the relevant pointcut.
        		]]>
        			<programlisting language="xml"><emphasis
        			role="bold"><![CDATA[<aop:around]]></emphasis><![CDATA[ method="aroundExecuteUpdateMethod" pointcut-ref="updateMethods">]]></programlisting>
        		</para>

        		<para>
        			The following is a part of PrintStringUsingXML class which implements Around Advice.
        			aroundExecuteUpdateMethod(), which performs Around
        			Advice role, plays a role of showing class name and method name with 
        			 "Around Advice of PrintStringUsingXML" string and the relevant pointcut
        			 after 'updateMethods()' pointcut.
        		
        			<programlisting language="java">public class PrintStringUsingXML {
    // ...
	
    public Object <emphasis role="bold">aroundExecuteUpdateMethod(ProceedingJoinPoint thisJoinPoint)</emphasis>
            <emphasis role="bold">throws Throwable</emphasis> {
        Class targetClass = thisJoinPoint.getTarget().getClass();
        Signature signature = thisJoinPoint.getSignature();
        String opName = signature.getName();

        System.out.println("Around Advice of PrintStringUsingXML");
        System.out.println("***" + targetClass + "." + opName + "()" + "***");
        // before logic
        Object retVal = thisJoinPoint.proceed();
        // after logic
        return retVal;
    }
	
    // ...
}</programlisting></para>

        		<para>
        			
        			aroundExecuteUpdateMethod() has one input parameter(ProceedingJoinPoint)which 
        			can execute the target pointcut by calling ' proceed()' method
        			and also contains target information such as target class name, method name, etc.
      				In other words, pre/post-process of pointcut is possible and also it is possible to decide
        			execution time of pointcut.
        			In addition, unlike other advice, it is possible to modify input value, target, return value, etc.
        			In the case of advice which requires no target information,
        			there is no need to declare 'ProceedingJoinPoint' input parameter.
      				
      			
    
        		</para>
      		</section>
      	</section>
      	
      	<section id="foundation_spring_aop_xmlbasedaop_runaspect">
      	<title>Aspect execution</title>

      		<para>
      			Now, let's check whether above-mentioned Aspect are working properly by using test code Main.java.
       			The following is main()method of test code Main.java, and checks whether LoggingAspect defined with Before Advice
       			works properly by executing CRUD logic on the actual product.
      		
				<programlisting language="java">public static void main(String[] args) throws Exception {
        Main main = new Main();

        // 1. initialize context
        main.setup();
        // 2. test
        main.manageProduct();
        // 3. close context
        main.teardown();
    }

    public void manageProduct() throws Exception {
        // 1. lookup productService, categoryService
        ProductService productService = (ProductService) context.getBean("productService");

        // 2. create a new product
        Product product = new Product();
        product.setProdNo("PRODUCT-99999");
        product.setProdName("sample.sportsone");
        product.setProdDetail("sports one detail");
        product.setSellerId("woos41");
        product.setAsYn("Y");
        product.setManufactureDay("20081225");
        product.setSellAmount(new Long(50));
        product.setSellQuantity(new Long(50));
        productService.create(product);

        // 3. get product list
        ProductSearchVO searchVO = new ProductSearchVO();
        searchVO.setSearchCondition("0");
        searchVO.setSearchKeyword("sample.sportsone");
        Page products = productService.getPagingList(searchVO);
        System.out.println("after creating a new product, product size is a '"
                        + products.getSize() + "'.");

        // 4. update a product
        product.setProdName("sportsone-update");
        product.setProdDetail("sports one detail-update");
        productService.update(product);

        // 5. get a product
        Product result = productService.get(product.getProdNo());
        System.out.println("after updating a product, product name is a '"
                        + result.getProdName() + "'.");

        // 6. remove a product
        productService.remove(product.getProdNo());

        // 7. get product list
        searchVO = new ProductSearchVO();
        searchVO.setSearchCondition("0");
        searchVO.setSearchKeyword("sample.sportsone");
        products = productService.getPagingList(searchVO);
        System.out.println("after creating a new product, product size is a '"
                        + products.getSize() + "'.");
    }
}</programlisting>
			</para>

      		<para>
      			When executing first logic,productService.create(product);, LoggingAspect defined as Before Advice is applied,
      			and the execution result is shown in the console window as the following.
      	
				<programlisting
				language="java">** Logging Aspect : executed initialize() in anyframe.sample.aop.sales.service.impl.productserviceimpl Class.
No arguments
** Logging Aspect : executed initialize() in anyframe.sample.aop.sales.service.impl.productserviceimpl Class.
No arguments</programlisting>
			</para>

      		<para>
      			When executing second logic, productService.getPagingList(searchVO);,LoggingAspect defined as before Advice is applied,
      			and the execution result is shown in the console window as the following.
      		
				<programlisting
				language="java">** Logging Aspect : executed getPagingList() in anyframe.sample.aop.sales.service.impl.productserviceimpl Class.
*************anyframe.sample.aop.sales.service.ProductSearchVO*************
 searchCondition - 0
 searchKeyword - sample.sportsone
 pageIndex - 1

*******************************************

** Logging Aspect : executed getPagingList() in anyframe.sample.aop.sales.service.impl.productserviceimpl Class.
*************anyframe.sample.aop.sales.service.ProductSearchVO*************
 searchCondition - 0
 searchKeyword - sample.sportsone
 pageIndex - 1

*******************************************

after creating a new product, product size is a '1'.</programlisting>
			</para>
  		</section>
  	</section>
  	
  	<section id="foundation_spring_aop_aspectj">
    <title>AspectJ based AOP</title>

    	<para>
    		Now, let's take a look at how to define and test Aspect
    		by using AspectJ among main AOP tools.
    	
    	</para>
    	
    	<section id="foundation_spring_aop_aspectj_beforestart">
      	<title>Before starting</title>

      		<para>To use AspectJ, it is needed to check the following items.
      	</para>

      		<orderedlist>
        		<listitem>
          			<para>
          				AJDT, AJDT(AspectJ Development Tool) installment Eclipse plugin, is a development tool
          				for creating and compiling Aspect file.
          				If Plugin AJDT(AspectJ
          				Development Tool) is not installed within Eclipse in use,
          				it is recommended to download and install AJDT(AspectJ Development Tool)into Eclipse in use.
          				If you want to compile Aspect without using AJDT,
          				use Ant task "iajc" defined in aspectjtools-1.5.4.jar.
          				The following is the content of compile target of sample build.xml file.
          			
          			</para>

          	<programlisting language="xml"><![CDATA[<target name="compile" depends="init">
    <taskdef resource="org/aspectj/tools/ant/taskdefs/aspectjTaskdefs.properties">
        <classpath>
            <pathelement location="${lib.dir}/aspectjtools-1.5.4.jar" />
        </classpath>
    </taskdef>]]>

   <emphasis role="bold"><![CDATA[<iajc]]></emphasis><![CDATA[ verbose="true" destdir="${output.dir}" debug="on" source="1.5"
             showweaveinfo="true" xnoinline="true">
    <sourceroots>
        <pathelement location="src/main/java" />
    </sourceroots>
    <classpath>
        <pathelement location="${lib.dir}/aspectjrt-1.5.4.jar" />
        <pathelement location="${lib.dir}/commons-logging-1.0.4.jar" />
    </classpath>]]>
   <emphasis role="bold"><![CDATA[</iajc>]]></emphasis>
<![CDATA[</target>]]></programlisting>
        </listitem>

        <listitem>
        	 		<para>
        	 				<![CDATA[Convert to AspectJ Project : For sepcific project to recongize Aspect file whose extension is aj,
        	 				select context menu AspectJ Tools > Convert to
          				AspectJ Project for the relevant project
          				and assign the characteristic of  AspectJ on the project.]]>
        	 			
          			</para>

          			<mediaobject>
            			<imageobject>
            	  			<imagedata align="center" fileref="../image/foundation/spring/convert_aop_project.JPG" />
            			</imageobject>
          			</mediaobject>
        		</listitem>
      		</orderedlist>
    	</section>
    	
    	<section id="foudation_spring_aop_aspectj_aspect">
      	<title>Aspect definition</title>

      		<para>
      			Creates a file whose extension is 'aj' and defines Aspect class by using aspect.
      			The following LoggingAspect shows that the relevant class is Aspect by using aspect.
      		
      		</para>

      <programlisting language="java">public <emphasis role="bold">aspect LoggingAspect</emphasis> {
    // ...
}</programlisting>
    	</section>
    	
    	<section id="foundation_spring_aop_aspectj_pointcut">
      	<title>Pointcut definition</title>

      		<para>
      			Defines the part of apply the relevant Aspect to by using pointcut.
      			(When defining Pointcut, refer to <link
      			linkend="foundation_spring_aop_components_pointcut">How to utilize Pointcut Designator and Pattern
	      		Matching</link>.)
	      		The following defines Pointcut of LoggingAspect.
	      		Pointcut was defines as "execution(* *..GenericService+.*(..))"
	      		and 'serviceMethod()' method was assigned as an identifier of the relevant pointcut.
	      		This means that execution part of all methods whose class names ends with GenericService
	      		are pointcut to apply Aspect to.
	      		The relevant pointcut can be used under the name of serviceMethod().
      		
	      		<programlisting language="java"><emphasis
      			role="bold">pointcut serviceMethod():</emphasis> execution(* *..GenericService+.*(..));</programlisting>
      		</para>
    	</section>
    	
    	<section id="foundationspring_aop_aspectj_advice">
   		<title>Advice definition</title>
    	
    		<para>Now, let's take a look at how to define Advice by the time of running in AspectJ.
    	</para>
    	
    		<section id="foundation_spring_aop_aspectj_advice_before">
        	<title>Before Advice</title>

        		<para>
        			Defines Before Advice by using before().
        			The following defines Before Advice of PrintStringUsingAspctJ.
        			Before Advice plays a role of showing the class name and method name with 
        			"Before Advice of PrintStringUsingAspctJ" string and the relevant pointcut
        			before above-mentioned 'getMethods() pointcut.
        			 <programlisting language="java"><emphasis
              		role="bold">before() : getMethods()</emphasis>{
    Class targetClass = thisJoinPoint.getTarget().getClass();
    Signature signature = thisJoinPoint.getSignature();
    String opName = signature.getName();

    System.out.println("Before Advice of PrintStringUsingAspctJ");
    System.out.println("***" + targetClass + "." + opName + "()" + "***");		
}</programlisting>
				</para>

        		<para>
        			Above-mentioned Before Advice extracts target information such as target class name and method name
        			by using internally-defined JoinPoint-type 'thisJoinPoint' object.
        	
        		</para>
      		</section>
      		
      		<section id="foundation_spring_aop_aspectj_advice_afterreturning">
        	<title>AfterReturning Advice</title>

        		<para>
        			Defines AfterReturning Advice by using after() returning().
        			The following defines AfterReturning Advice of PrintStringUsingAspctJ
        			and defines that execution result of the relevant pointcut is contained in 'retVal' variable.
        			AfterReturning Advice plays a role of showing the class name and method name with 
        			"AfterReturning Advice of PrintStringUsingAspctJ" string and the relevant pointcut
        			before above-mentioned 'getMethods() pointcut.
        		 <programlisting
        			language="java"><emphasis role="bold">after() returning(UserVO retVal) : getMethods()
</emphasis> {
    Class targetClass = thisJoinPoint.getTarget().getClass();
    Signature signature = thisJoinPoint.getSignature();
    String opName = signature.getName();

    System.out.println("AfterReturning Advice of PrintStringUsingAspctJ");
    System.out.println("***" + targetClass + "." + opName + "()" + "***");
}</programlisting>
				</para>

        		<para>
        			Above-mentioned AfterReturning Advice extracts target information such as target class name and method name
        			by using internally-defined JoinPoint-type 'thisJoinPoint' object.
        			In addition, it has one input parameter(UserVO), which is an execution result of the relevant pointcut.
        			If it is needed to refer to execution result of specific pointcut at AfterReturning
        			Advice, define object relevant to 'returning' when defining Advice
        			and utilize it within method logic.
        			Input parameter can be selectively defined depending on the need when defining AfterReturning Advice.
        		
        		</para>
      		</section>
      		
      		<section id="foundation_spring_aop_aspectj_advice_afterthrowing">
        	<title>AfterThrowing Advice</title>

        		<para>
        			Defines AfterThrowing Advice by using after() throwing().
        			The following defines AfterThrowing Advice of  PrintStringUsingAspctJ
        			and defines that exception object occurred when executing the relevant pointcut is contained in 'exception' variable.
        			AfterThrowing Advice plays a role of showing the class name and method name with 
        			"AfterThrowing Advice of PrintStringUsingAspctJ" string and the relevant pointcut
        			after exception occurs in the above-defined pointcut.
        		</para>

        		<para>
        		<programlisting language="java"><emphasis
        		role="bold">after() throwing(Exception exception) : getMethods()</emphasis> {
    Class targetClass = thisJoinPoint.getTarget().getClass();
    Signature signature = thisJoinPoint.getSignature();
    String opName = signature.getName();

    System.out.println("AfterThrowing Advice of PrintStringUsingAspctJ");
    System.out.println("***" + targetClass + "." + opName + "()" + "***");
}</programlisting>
					Above-mentioned AfterThrowing Advice extracts target information such as target class name and method name
        			by using internally-defined JoinPoint-type 'thisJoinPoint' object.
        			In addition, it has one input parameter(Exception), which is an execution result of the relevant pointcut.
        			If it is needed to refer to execution result of specific pointcut at AfterReturning
        			Advice, utilize the object relevant to 'throwing' within method logic when defining Advice.
        			Input parameter can be selectively defined depending on the need when defining AfterThrowing Advice.
					
        		</para>
      		</section>
      		
      		<section id="foundation_spring_aop_aspectj_advice_after(finally)">
        	<title>After(finally) Advice</title>

        		<para>
        			Defines After(finally) Advice by using after().
        			The following defines After(finally) Advice of  PrintStringUsingAspctJ.
        			After(finally) Advice plays a role of showing the class name and method name with 
        			"After(finally) Advice of PrintStringUsingAspctJ" string and the relevant pointcut
        			after above-defined 'getMethods()' pointcut.
        		
        			<programlisting language="java"><emphasis role="bold">after() : getMethods()</emphasis> {
    Class targetClass = thisJoinPoint.getTarget().getClass();
    Signature signature = thisJoinPoint.getSignature();
    String opName = signature.getName();

    System.out.println("After(finally) Advice of PrintStringUsingAspctJ");
    System.out.println("***" + targetClass + "." + opName + "()" + "***");		
}</programlisting>
				</para>

 		       	<para>
 		       		Above-mentioned After(finally) Advice extracts target information such as target class name and method name
        			by using internally-defined JoinPoint-type 'thisJoinPoint' object.
 		       		
 		       	</para>
      		</section>
      
      		<section id="foundation_spring_aop_aspectj_advice_around">
      		<title>Around Advice</title>

				<para>
        			Defines  Around Advice by using around().
        			The following defines Around Advice of PrintStringUsingAspctJ
        			and shows that return type definition is added, unlike other Advice.
        			Around Advice plays a role of showing the class name and method name with 
        			"Around Advice of PrintStringUsingAnnotation" string and the relevant pointcut
        			before 'updateMethods()' pointcut.
        			
        			<programlisting language="java"><emphasis role="bold">Object around() : updateMethods()</emphasis> {
    Class targetClass = thisJoinPoint.getTarget().getClass();
    Signature signature = thisJoinPoint.getSignature();
    String opName = signature.getName();

    System.out.println("Around Advice of PrintStringUsingAspctJ");
    System.out.println("***" + targetClass + "." + opName + "()" + "***");
    // before logic
    <emphasis role="bold">Object retVal = proceed();</emphasis>
    // after logic
    return retVal;		
}</programlisting>
				</para>

				<para>
				
        			Above-mentioned Around Advice extracts target information such as target class name and method name
        			by using internally-defined JoinPoint-type 'thisJoinPoint' object.
        			
        			As it can execute the target pointcut by calling ' proceed()' method
        		    pre/post-process of pointcut is possible and also it is possible to decide
        			execution time of pointcut.
        			In addition, unlike other advice, it is possible to modify input value, target, return value, etc.
        	
        		</para>
      		</section>
 		</section>	
  	</section>
  	
  	<section id="foundation_spring_aop_examples">
    <title>AOP Examples</title>

    	<para>
    		Aspect can be applied to many parts.
    		This page will cover various examples and show how to apply in detail.
    		For more details, refer to link on each item listed below.
    	
    	</para>
    	
    	<section id="foundation_spring_aop_examples_logging">
      	<title>AOP Example - Logging</title>

	      	<para>
	      		If error occurs when testing developed application,
	      		usually DEBUG-level log or System.out.println() string
	      		 is added for checking input value within the relevant method, which will be
	      		mixed with core business logic causing raised complexity of code.
	      		Therefore, if you define and utilize separate Aspect to check sending input value when defining specific method,
	      		you can exclude logics for checking input value within relevant method.
	      		The following will create and test Logging Aspect by using  @AspectJ(Annotation) among main AOP tools.
	      		Application target of Logging Aspect is GenericService, which will play a role of leaving the value of 
	      		input parameter for executing relevant method before executing them.
	      
	      	</para>
	      	
	      	<section id="foundation_spring_aop_examples_logging_configuration">
        	<title>Configuration</title>

        		<para>
        			To execute Pointcut, Advice defined in the relevant class by loading @AspectJ(Annotation)-applied class,
        			it is needed to add the following in the Spring configuration xml file.
        		
        			<programlisting language="xml"><![CDATA[<aop:aspectj-autoproxy/>]]></programlisting>
        		</para>
      		</section>
      		
      		<section id="foundation_spring_aop_examples_logging_aspect">
        	<title>Aspect definition</title>

        		<para>
        			Creates 'LoggingAspect' Aspect class composed of annotation as the following.
        			Plays a role of leaving the relevant method information and input parameter value as a log
        			before executing all method whose class ends with 'LoggingAspect' GenericService.
        			
        			<programlisting language="java"><![CDATA[@Aspect
public class LoggingAspect {
    @Pointcut("execution(* *..GenericService+.*(..))")
    public void serviceMethod(){}
	
    @Before("serviceMethod()")
    public void beforeLogging(JoinPoint thisJoinPoint) {
        Class clazz = thisJoinPoint.getTarget().getClass();
        String className = (thisJoinPoint.getTarget().getClass().getName()).toLowerCase();
        String methodName = thisJoinPoint.getSignature().getName();

        StringBuffer buf = new StringBuffer();
        buf.append("\n** Logging Aspect : executed " + methodName + "() in " + className
                + " Class.");
        Object[] arguments = thisJoinPoint.getArgs();
        if (arguments.length > 0) {
            for (int i = 0; i < arguments.length; i++) {
                buf.append("\n*************" + arguments[i].getClass().getName()
                        + "*************\n");
                buf.append(arguments[i].toString());
                buf.append("\n*******************************************\n");
            }
        } else
            buf.append("\nNo arguments\n");

        Log logger = LogFactory.getLog(clazz);
        if (logger.isDebugEnabled())
            logger.debug(buf.toString());
    }
}]]></programlisting></para>

        		<para>
        			Indicates that beforeLogging() method leaves log of method information of the relevant method and input parameter value
                    through
        			logger of target class, by using 'JoinPoint' object.
        		
        		</para>
      		</section>
      		
      		<section id="foundation_spring_aop_examples_logging_runaspect">
        	<title>Aspect execution</title>

				<para>
					If you execute Main.java class composed of Product CRUD by calling productService,
					Logging Aspect is applied and log in the following format can be seen through console window.
			
        			<programlisting
        			language="java">2009-12-01 16:33:55,468 DEBUG [anyframe.sample.aop.sales.service.impl.ProductServiceImpl] 
** Logging Aspect : executed initialize() in anyframe.sample.aop.sales.service.impl.productserviceimpl Class.
No arguments

2009-12-01 16:33:55,468 DEBUG [anyframe.sample.aop.sales.service.impl.ProductServiceImpl] 
** Logging Aspect : executed initialize() in anyframe.sample.aop.sales.service.impl.productserviceimpl Class.
No arguments

2009-12-01 16:33:55,781 DEBUG [anyframe.sample.aop.sales.service.impl.ProductServiceImpl] 
** Logging Aspect : executed getPagingList() in anyframe.sample.aop.sales.service.impl.productserviceimpl Class.
*************anyframe.sample.aop.sales.service.ProductSearchVO*************
 searchCondition - 0
 searchKeyword - sample.sportsone
 pageIndex - 1

*******************************************

2009-12-01 16:33:55,781 DEBUG [anyframe.sample.aop.sales.service.impl.ProductServiceImpl] 
** Logging Aspect : executed getPagingList() in anyframe.sample.aop.sales.service.impl.productserviceimpl Class.
*************anyframe.sample.aop.sales.service.ProductSearchVO*************
 searchCondition - 0
 searchKeyword - sample.sportsone
 pageIndex - 1

*******************************************

after creating a new product, product size is a '1'.
after updating a product, product name is a 'sportsone-update'.
2009-12-01 16:33:55,906 DEBUG [anyframe.sample.aop.sales.service.impl.ProductServiceImpl] 
** Logging Aspect : executed getPagingList() in anyframe.sample.aop.sales.service.impl.productserviceimpl Class.
*************anyframe.sample.aop.sales.service.ProductSearchVO*************
 searchCondition - 0
 searchKeyword - sample.sportsone
 pageIndex - 1

*******************************************

2009-12-01 16:33:55,906 DEBUG [anyframe.sample.aop.sales.service.impl.ProductServiceImpl] 
** Logging Aspect : executed getPagingList() in anyframe.sample.aop.sales.service.impl.productserviceimpl Class.
*************anyframe.sample.aop.sales.service.ProductSearchVO*************
 searchCondition - 0
 searchKeyword - sample.sportsone
 pageIndex - 1

*******************************************

after creating a new product, product size is a '0'.</programlisting></para>
     	 	</section>
		</section>
		
		<section id="foundation_spring_aop_examples_exceptiontransfer">
      	<title>AOP Example - Exception Transfer</title>

      		<para>
      			
      			For log and message handling on the exception that can occur when performing specific business logic,
      			exception handling logic must be added to core business logic.
      			Therefore, due to 'try~catch' block will be repeated at every logic in addition to core business logic,
      			leading to more complexity of code.
      			If exceptions are handled in common through separate aspect and 'try~catch' block can be removed
      			from each business logic, codes will become much simpler and, ultimately, developers will be able to focus
      			only on business logic.
      			The following will create and test aspect for ExceptionTransfer in xml scheme by using Spring AOP
      			among main AOP tools.
      			Application target of ExceptionTransfer Aspect will play a role of handling of exception, if any, 
      			occurred at all methods whose class ends with GenericService.
      		
      		</para>
      		
      		<section id="foundation_spring_aop_examples_exceptiontransfer_aspect">
        	<title>Aspect definition</title>

        		<para>
        			Define Aspect class as a bean in Spring Configuration XML(context-xml.xml ) file,
        			and define Pointcut and advice for the relevant 
        		
       				<programlisting language="xml"><![CDATA[<aop:config>
    <aop:pointcut id="serviceMethod" expression="execution(* *..GenericService+.*(..))" />
    <aop:aspect ref="exceptionTransfer" order="1"> 
        <aop:after-throwing throwing="exception" pointcut-ref="serviceMethod" method="transfer" />					
    </aop:aspect>
</aop:config>]]></programlisting></para>

        		<para>
        			ExceptionTransfer plays a role of handling exception occurred at all methods whose class ends with GenericService.
        		
        		</para>
      		</section>
      		
      		<section id="foundation_spring_aop_examples_exceptiontransfer_advice">
        	<title>Advice implementation</title>

  		    	<para>
  		    		Creates 'ExceptionTransfer' Aspect class as the following.
  		   
  		    		<programlisting language="java">public class ExceptionTransfer {
    private MessageSource messageSource;

    public void setMessageSource(MessageSource messageSource) {
        this.messageSource = messageSource;
    }	

    public void transfer(JoinPoint thisJoinPoint, Exception exception)
            throws SalesException {
        Object target = thisJoinPoint.getTarget();
        while (target instanceof Advised) {
            try {
                target = ((Advised) target).getTargetSource().getTarget();
            } catch (Exception e) {
                LogFactory.getLog(this.getClass()).error(
                        "Fail to get target object from JointPoint.", e);
                break;
            }
        }

        String className = target.getClass().getSimpleName().toLowerCase();
        String opName = (thisJoinPoint.getSignature().getName()).toLowerCase();
        Log logger = LogFactory.getLog(target.getClass());

        if (exception instanceof SalesException) {
            SalesException empEx = (SalesException) exception;
            logger.error(empEx.getMessage(), empEx);
            throw empEx;
        }
		
        if (exception instanceof BaseException) {
            BaseException baseEx = (BaseException) exception;
            logger.error(baseEx.getMessage(), baseEx);
            throw new SalesException(messageSource, "error." + className + "." + opName
                                ,new String[] {}, exception);
        }		

        logger.error(messageSource.getMessage("error." + className + "."
                + opName, new String[] {}, "no messages", Locale.getDefault()),	exception);

        throw new SalesException(messageSource, "error." + className + "."
                + opName, new String[] {}, exception);
    }
}</programlisting></para>

        		<para>
        			transfer() method divides the type of occurred exception into SalesException, BaseException, and others,
        			and gets the relevant message by using message key which combines target class and method name where exception occurred.
        			Then, it leaves ERROR-level log by using this message and concert to SalesException and throw.
        			
        		</para>
      		</section>
		</section>
		
		
		<section id="foundation_spring_aop_examples_profiler">
      	<title>AOP Example - Profiler</title>

      		<para>
      			Can measure execution time for some methods whose response speed is important at the development stage
      			through Aspect without any separate function measuring.
      			That way, is becomes possible to check and handle the parts causing weakened performance, at the stage of development.
      		
      		</para>
      		<para>
      			The following will create and test SimpleProfiler Aspect by using @AspectJ(Annotation) among main AOP tools.
      			Application target of SimpleProfiler Aspect is UserService,
      			which will play of role of measuring time spent on executing specific method(add*) and leave a log on consol.
      			
      		</para>
      		
      		<section id="foundation_spring_aop_examples_profiler_configuration">
        	<title>Configuration</title>

        		<para>
        			To execute Pointcut, Advice defined in the relevant class by using @AspectJ(Annotation)-applied class,
        			add the following to Spring configuration xml file.
        	
        			<programlisting language="xml"><![CDATA[<aop:aspectj-autoproxy/>]]></programlisting>
        		</para>
      		</section>
      
      		<section id="foundation_spring_aop_examples_profiler_aspect">
      		<title>Aspect definition</title>

				<para>
				
					Creates 'SimpleProfiler' Aspect class composed of annotation as the following.
					SimpleProfiler targets method whose method name begins with 'add' in all classes whose class name ends with 'Impl'
					among all classes in anyframe.sample package.
					And this will play a role of measuring time spent on method execution and leaving a log on console
					by using StopWatch provided in Spring before/after executing the relevant method.
					
		        	<programlisting language="java">@<emphasis role="bold">Aspect</emphasis>
public class SimpleProfiler {
    @<emphasis role="bold">Pointcut("execution(* anyframe.sample.aop.service..*Impl.add*(..))")</emphasis>
    public void addMethods() {
    }
		
    @<emphasis role="bold">Around("addMethods()")</emphasis>
    public Object profile(ProceedingJoinPoint thisJoinPoint) throws Throwable {
        String className = thisJoinPoint.getSignature().getDeclaringTypeName();
        StopWatch stopWatch = new StopWatch("Profiling for [" + className + "]");
        try {
            stopWatch.start(thisJoinPoint.toShortString());
            return thisJoinPoint.proceed();
        } finally {
            stopWatch.stop();
            System.out.println(stopWatch.shortSummary());
        }
    }
}</programlisting></para>
		    </section>
		      
		    <section id="foundation_spring_aop_examples_profiler_runaspect">
			<title>Aspect execution</title>

       		<para>
       			If you call UserService and execute SimpleProfilerAspectTest which calls registration of new user information and where logic of stopping for
       			1000 milliseconds at implementation logic is added,
       			SimpleProfiler Aspect is applied and you can see a log in the console window as the following.
       		
        		<programlisting language="java">StopWatch 'Profiling for [anyframe.sample.aop.service.UserServiceImpl]'
: running time (millis) = 1016</programlisting>
			</para>
      		</section>
		</section>
		
		<section id="foundation_spring_aop_examples_designlevelassertion">
      	<title>AOP Example - Design Level Assertions</title>

      		<para>
      			Development standard guides to perform development task according to the already-verified S/W architecture style
      			in all kinds of naming standard and the relevant project.
      			This reduces confusion that developers will have to face in the beginning stage of development
      			and enables developers to focus only on business logic, thereby making it easier to maintain or modify
      			code abiding by same standard.
      			In most projects, it is recommended that developers spend a significant amount of time to separately define
      			development standard suitable for the relevant project before application is developed in earnest, and that
      			developers will perform a development task abiding by such standard.
      			In reality, however, it is not well abided by and there is a limit to verify this as well.
      			
      		</para>

      		<para>
      			If it is possible to apply development standard at code compiling,
      			it will be able to recognize and modify unsuitable code easily at coding.
      			To this end, this document will define  Design Rule as  Aspect composed of declare error/warning
      			and cover how to modify unsuitable items.
      	
      		</para>

      		<para>
      			First, define 'declare error/warning' string as the following.
      			If JoinPoint relevant to Pointcut Expression, defined message will be shown.
      		
      			<programlisting language="java">@DeclareWarning ("Pointcut Expressions")
static final String varialableName = "msg...";
</programlisting>
			</para>

 		    <para>The following is a part of S/W architecture diagram 
 		    which can be seen more frequently when developing Anyframe-based application.
 	</para>

		    <mediaobject>
		      <imageobject>
		        <imagedata align="center" fileref="../image/foundation/spring/sw_architecture.jpg" />
		      </imageobject>
		    </mediaobject>

      		<para>
      			Let's assume that the package of the relevant application begins with 'com.sds.emp'
      			and presentation layer is located within 'com.sds.emp.{submodule name}.web', and business layer
      			is within 'com.sds.emp.{submodule name}.services'.
      		
      		</para>

      		<para>
      			Definable Design Rule is mainly divided into <link
      			linkend="foundation_spring_aop_examples_designlevelassertion_interaction">Interaction Rule</link> ,
      			<link linkend="foundation_spring_aop_examples_designlevelassertion_naming">Naming Rule</link>.
      			Now, let's take a look at definition of Design Rule based on the figure above.
      		
    		</para>
    		
    		<section id="foundation_spring_aop_examples_designlevelassertion_interaction">
        	<title>Interaction Rule definition example</title>

		        <para>
		        	Defined Interaction Rule among classes by defining pointcut necessary for package level, class level, etc.
		        	and combing above-mentioned pointcut at Declare string.
		        	This is for reuse of already-defined pointcut in other Declare string.
		        	The following is a part of Interaction Rule defined in DevStandard Aspect.
		        	
	        	</para>

	        	<orderedlist>
	          		<listitem>
	            	<para>
	            		<emphasis role="bold">Cannot call action or form class at classes which don't belong to presentation layer. 
	            		</emphasis>
	            		<programlisting language="java">// JoinPoint whose package name begins with 'com.sds.emp' and contains 'web' in the middle
	            		
@Pointcut("within(com.sds.emp..web..*)")
public void <emphasis role="bold">inWebPkg()</emphasis><![CDATA[ {}

// JoinPoint which calls all methods of classes whose class name ends with 'Action' or 'Form'

@Pointcut("call(* com.sds.emp..web.*Action.*(..)) && call(* com.sds.emp..web.*Form.*(..))")
public void ]]><emphasis role="bold">callToWeb()</emphasis> {}	
	
// When calling Action or Form class in web package in the class which don't belong to web package
// error message will be shown as the following.
@<emphasis role="bold"><![CDATA[DeclareError("!inWebPkg() && callToWeb()")]]></emphasis>
<emphasis role="bold">static final String irMsg5 = "Failed to access all classes which belong to web package." ;
</emphasis></programlisting>
					</para>
					</listitem>

        	  		<listitem>
            		<para>
            			<emphasis role="bold">In presentation layer, specific service must be accessed via Interface.
            			 </emphasis>
            			<programlisting
            			language="java">// JoinPoint which belongs to all package whose package name begins with 'com.sds.emp' and contains 'web' in the middle.
            		
@Pointcut("within(com.sds.emp..web..*)")
public void <emphasis role="bold">inWebPkg()</emphasis> {}

//JoinPoint which calls all methods of the class whose class name ends with 'DAO'

@Pointcut("call(* com.sds.emp..services.impl.*DAO.*(..))")
public void <emphasis role="bold">callToDAO()</emphasis> {}

// JoinPoint which calls all methods of the class whose class name ends with 'Impl'

@Pointcut("call(* com.sds.emp..services.impl.*Impl.*(..))")
public void <emphasis role="bold">callToImplementation()</emphasis> {}
	
// In the case of directly calling method in DAO or Impl at web package, error message will be shown as the following.

@<emphasis role="bold"><![CDATA[DeclareError("inWebPkg() && ( callToDAO() || callToImplementation())")]]></emphasis>
<emphasis role="bold">static final String irMsg1 = "Access to implementation class or DAO class of specific service in Action class
"</emphasis>
<emphasis role="bold">+ "has failed."; </emphasis></programlisting>
					</para>
          			</listitem>

          			<listitem>
           			<para>
           				<emphasis role="bold">Forces not to directly use specific object(java.sql.Connection).
           				 </emphasis>
           				<programlisting
           				language="java">// JoinPoint which belongs to all test package whose package name begins with 'integration' or 'unit'
           			
@Pointcut("within(integration..* || unit..*)")
public void <emphasis role="bold">inTestPkg()</emphasis> {}

// JoinPoint which calls all method of java.sql.Connection class

@Pointcut("call(* java.sql.Connection.*(..))")
public void <emphasis role="bold">callToConnection()</emphasis> {}

// In the case of directly calling Connection object at all package except test package,

// error message will be shown.
@<emphasis role="bold"><![CDATA[DeclareError("callToConnection() && !inTestPkg()")]]></emphasis>
<emphasis role="bold">static final String irMsg2 = "Failed to access java.sql.Connection object."</emphasis>
<emphasis role="bold">+ "Please use Anyframe Service.";</emphasis></programlisting></para> 
        			</listitem>

	        	  	<listitem>
					<para>
						<emphasis role="bold">Cannot create DAO instance by directly calling constructor.
            			Must define relation among objects through Dependency Injection.
            			</emphasis>
            			<programlisting language="java">// JoinPoint which calls constructor of DAO class
@Pointcut("call(com.sds.emp..services.impl.*DAO.new(..))")
public void <emphasis role="bold">callToDAOConstructor()</emphasis> {}

// In the case of directly calling constructor of DAO class, error message will be shown as the following.

@<emphasis role="bold">DeclareError("callToDAOConstructor()")</emphasis>
<emphasis role="bold">static final String irMsg3 = "Failed to directly create DAO instance."</emphasis>
<emphasis role="bold">+ "For reference among objects, define and use service configuration xml.";  </emphasis></programlisting></para>
          			</listitem>
        		</orderedlist>
      		</section>
      	
      		<section id="foundation_spring_aop_examples_designlevelassertion_naming">
        	<title>Naming Rule definition example</title>

	        	<para>
	        		Defined Naming Rule among classes by defining pointcut necessary for package level, class level, etc.
		        	and combing above-mentioned pointcut at Declare string.
		        	This is for reuse of already-defined pointcut in other Declare string.
		        	The following is a part of Interaction Rule defined in DevStandard Aspect.
	        	
	        	</para>
	
	 	       	<orderedlist>
	          		<listitem>
	            		<para>
	            		<emphasis role="bold">Class name existing in  com.sds.emp.{submodule name}.web package must end with 'Action' or 'Form'.
	            	</emphasis><programlisting
    	        		language="java">//JoinPoint which belongs to all packages whose package name begins with 'com.sds.emp' and contains 'web' in the middle
    	        		
@Pointcut("within(com.sds.emp..web..*)")
public void <emphasis role="bold">inWebPkg()</emphasis> {}

//All JoinPoint which is not method or Constructor, method logic. Namely, only class definition part.

@Pointcut("!(execution(* *(..)) || withincode(*.new(..)) || withincode(* *(..)))")
public void <emphasis role="bold">clazz()</emphasis>{}

// Among JoinPoint which belong to all packages whose package name begins with 'com.sds.emp' and contains 'web' in the middle,
// all JoinPoint which belongs to class whose class name ends with 'Action'.

@Pointcut("within(com.sds.emp..web..*Action)")
public void <emphasis role="bold">actionName()</emphasis> {}

// Among JoinPoint which belong to all packages whose package name begins with 'com.sds.emp' and contains 'web' in the middle,
// all JoinPoint which belongs to class whose class name ends with 'Form'

@Pointcut("within(com.sds.emp..web..*Form)")
public void <emphasis role="bold">formName()</emphasis> {}		

// If there is definition which belongs to web package but has class which does not end with 'Action' or 'Form'
// warning message will be shown as the following.

@<emphasis role="bold"><![CDATA[DeclareWarning ("inWebPkg() && clazz() && !(actionName() || formName())")]]></emphasis>
<emphasis role="bold">static final String nrMsg2 = "All class names which belong to web package</emphasis> 
<emphasis role="bold">must end with 'Action' or 'Form'.";</emphasis></programlisting>
						</para>
         			</listitem>

          			<listitem>
            			<para>
          		  			<emphasis role="bold">Class name which exists in com.sds.emp.{submodule name}.services.impl package
          		  			must end with 'Impl' or 'DAO'
          		  			.</emphasis> <programlisting
            				language="java">// JoinPoint which belongs to all packages whose package name begins with 'com.sds.emp' and contains 'services.impl' in the middle
            			
@Pointcut("within(com.sds.emp..services.impl..*)")
public void <emphasis role="bold">inImplementationPkg()</emphasis> {}

// All JoinPoints which is not method or Constructor, method logic. Namely, only class definition part.

@Pointcut("!(execution(* *(..)) || withincode(* *(..)) || withincode(*.new(..)))")
public void <emphasis role="bold">clazz()</emphasis>{}

// Among JoinPoints which belongs to all packages whose package name begins with 'com.sds.emp' and contains 'services.impl' in the middle,
// all JoinPoints which belong to class whose class name ends with 'Impl'

@Pointcut("within(com.sds.emp..services.impl..*Impl)")
public void <emphasis role="bold">implementationName()</emphasis> {}

// Among JoinPoints which belongs to all packages whose package name begins with 'com.sds.emp' and contains 'services.impl' in the middle 
// All JoinPoints which belong to class whose class name ends with 'DAO'

@Pointcut("within(com.sds.emp..services.impl..*DAO)")
public void <emphasis role="bold">daoName()</emphasis> {}

//  If there is definition which belongs to services.impl package but has class which does not end with 'Impl' or 'DAO'
// warning message will be shown as the following.

@<emphasis role="bold"><![CDATA[DeclareWarning ("inImplementationPkg() && clazz() && !(implementationName() || daoName())")]]></emphasis>
<emphasis role="bold">static final String nrMsg4 = "All class names which belong to services package</emphasis>
<emphasis role="bold">must end with 'Impl' or 'DAO'";</emphasis></programlisting>
						</para>
          			</listitem>
        		</orderedlist>
      		</section>
      	
      		<section id="foundation_spring_aop_examples_designlevelassertion_refactoring">
        	<title>Refactoring</title>

        		<para>If application is developed based on Eclipse, it becomes easier to modify code which violated Design Rule.
        		.</para>

        		<orderedlist>
          			<listitem>
            			<para>
            				<![CDATA[If there is not Problems View in workspace, Select Eclipse menu Window >;
            		    	Show View > Problems and then open Problems view.
            			]]></para>
          			</listitem>

          			<listitem>
            			<para> Check items which violated Design Rule through Problems View.
            			</para>

			            <mediaobject>
			              <imageobject>
			                <imagedata align="center" fileref="../image/foundation/spring/problem_list.jpg" />
			              </imageobject>
			            </mediaobject>
	          		</listitem>

	          		<listitem>
	            		<para> Double-click items to modify at Problems View and then move to the target code.
	            	</para>
	
			            <mediaobject>
			              <imageobject>
			                <imagedata align="center"
			                           fileref="../image/foundation/spring/call_to_dao_constructor.jpg" />
			              </imageobject>
			            </mediaobject>
	          		</listitem>
	
	          		<listitem>
	            		<para>
	            			Remove Problem by modifying them to code abiding by Design Rule.
	            			<programlisting
	            			language="java">public void <emphasis role="bold">setUserDAO(UserDAO userDAO)</emphasis> {
    this.userDAO = userDAO;
}

public Page getUserList(SearchVO searchVO) throws EmpException {
    <emphasis role="bold">//UserDAO dao2 = new UserDAO();</emphasis>
    try {
        //...
    return <emphasis role="bold">userDAO.getUserList(searchVO);</emphasis>
    }
    //...
}</programlisting>
					</para>
        		</listitem>
    	    	</orderedlist>
      		</section>
		</section>
	</section>
	
	<section id="foundation_spring_aop_resources">
	<title>Resources</title>
		<para>
			<itemizedlist>
				<listitem>
					<para>Download</para>
					<para>
						Download  hsqldb.zip file which contains test DB and anyframe.sample.aop.zip file which contains sample code
						and then extract them in the following.
						Then, execute start.cmd (or start.sh) file in hsqldb folder and start test DB.
				
						<itemizedlist>
							<listitem>
								<para>Maven-based execution</para>
								<para>
									After moving to extracted directory in the command window,
									execute 'mvn compile exec:java -Dexec.mainClass=...' command and check the result.
									Refer to JavaDoc of Main class in each Eclipse project.
								
								</para>
							</listitem>
							<listitem>
								<para>Eclipse-based execution</para>
								<para>
									After importing extracted directory at Eclipse,
									select Main.Java under anyframe/sample/aop of src/main/java
									and click mouth right button, and then click Run As > Java Application on context menu.
									Then, check the execution result.
								
						</para>
							</listitem>
						</itemizedlist>
					</para>
					<table>
						<title>Download List</title>
						<tgroup cols="2">
							<colspec colnum="1" colname="col1" colwidth="4*" />
							<colspec colnum="2" colname="col2" colwidth="6*" />
							<thead>
								<row>
									<entry align="center">Name</entry>
									<entry align="center">Download</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry align="center">hsqldb.zip</entry>
									<entry align="center">
										<ulink url="http://dev.anyframejava.org/docs/anyframe/plugin/foundation/4.6.1/reference/sample/hsqldb.zip">Download</ulink>
									</entry>
								</row>
								<row>
									<entry align="center">anyframe.sample.aop.zip</entry>
									<entry align="center">
										<ulink url="http://dev.anyframejava.org/docs/anyframe/plugin/foundation/4.6.1/reference/sample/anyframe.sample.aop.zip">Download</ulink>
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</listitem>
				<listitem>
						<para>References</para>
						<itemizedlist>
							<listitem><para><ulink url="http://dev.anyframejava.org/anyframe/doc/core/3.2.1/downloads/corefw/guide/aop/AOP-Full.doc">Microsoftware which associates with ZDNet Korea- AOP</ulink></para></listitem>
						</itemizedlist>
					</listitem>
			</itemizedlist>
		</para>
	</section>
</chapter>